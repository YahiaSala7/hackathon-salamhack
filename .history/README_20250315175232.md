# React Query API Utility for Next.js

This project includes a reusable API utility built with React Query and Axios for Next.js applications. The utility provides a clean, consistent way to handle API requests with proper caching, error handling, and request management.

## Setup Instructions

### 1. Install Required Dependencies

```bash
npm install @tanstack/react-query @tanstack/react-query-devtools axios
# or
yarn add @tanstack/react-query @tanstack/react-query-devtools axios
```

### 2. Set Up React Query Provider

In your `_app.tsx` or `layout.tsx` file, set up the React Query provider:

```tsx
// _app.tsx (for Pages Router)
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60000, // 1 minute
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});

function MyApp({ Component, pageProps }) {
  return (
    <QueryClientProvider client={queryClient}>
      <Component {...pageProps} />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

export default MyApp;
```

For Next.js App Router, create a client component provider:

```tsx
// src/providers/ReactQueryProvider.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";

export default function ReactQueryProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60000,
            retry: 1,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

Then use it in your layout:

```tsx
// src/app/layout.tsx
import ReactQueryProvider from "../providers/ReactQueryProvider";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <ReactQueryProvider>{children}</ReactQueryProvider>
      </body>
    </html>
  );
}
```

### 3. Configure Environment Variables

Create a `.env.local` file in your project root:

```
NEXT_PUBLIC_API_URL=https://your-api-url.com
```

## API Utility Usage

The API utility provides both hook-based and direct function approaches for API calls.

### Hook-Based API Functions

#### 1. Fetching Data (GET)

```tsx
import { useFetchData } from "../utils/api";

function MyComponent() {
  const { data, isLoading, isError, error } = useFetchData("/users", {
    queryKey: ["users"],
    refetchOnWindowFocus: true,
  });

  if (isLoading) return <div>Loading...</div>;
  if (isError) return <div>Error: {error}</div>;

  return (
    <div>
      {data.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}
```

#### 2. Creating Data (POST)

```tsx
import { usePostData } from "../utils/api";

function CreateUserForm() {
  const createUserMutation = usePostData("/users", {
    invalidateQueries: [["users"]],
    onSuccess: (data) => {
      console.log("User created:", data);
    },
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    const userData = {
      name: "John Doe",
      email: "john@example.com",
    };
    createUserMutation.mutate(userData);
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <button type="submit" disabled={createUserMutation.isPending}>
        {createUserMutation.isPending ? "Creating..." : "Create User"}
      </button>
    </form>
  );
}
```

#### 3. Updating Data (PUT)

```tsx
import { usePutData } from "../utils/api";

function UpdateUserForm({ userId }) {
  const updateUserMutation = usePutData("/users", {
    invalidateQueries: [["users"], ["user", userId]],
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    const userData = {
      id: userId,
      name: "Updated Name",
    };
    updateUserMutation.mutate(userData);
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <button type="submit">Update User</button>
    </form>
  );
}
```

#### 4. Patching Data (PATCH)

```tsx
import { useUpdateData } from "../utils/api";

function PatchUserStatus({ userId }) {
  const patchUserMutation = useUpdateData("/users", {
    invalidateQueries: [["users"]],
  });

  const handleToggleActive = () => {
    patchUserMutation.mutate({
      id: userId,
      isActive: true,
    });
  };

  return <button onClick={handleToggleActive}>Activate User</button>;
}
```

#### 5. Deleting Data (DELETE)

```tsx
import { useDeleteData } from "../utils/api";

function DeleteUserButton({ userId }) {
  const deleteUserMutation = useDeleteData("/users", {
    invalidateQueries: [["users"]],
  });

  return (
    <button
      onClick={() => deleteUserMutation.mutate(userId)}
      disabled={deleteUserMutation.isPending}>
      {deleteUserMutation.isPending ? "Deleting..." : "Delete User"}
    </button>
  );
}
```

### Direct Function Approach

For cases where you need to make API calls outside of React components or in server-side code:

```tsx
import {
  fetchData,
  postData,
  putData,
  updateData,
  deleteData,
} from "../utils/api";

// GET request
const getUsers = async () => {
  try {
    const users = await fetchData("/users");
    return users;
  } catch (error) {
    console.error("Failed to fetch users:", error);
  }
};

// POST request
const createUser = async (userData) => {
  try {
    const newUser = await postData("/users", userData);
    return newUser;
  } catch (error) {
    console.error("Failed to create user:", error);
  }
};

// And so on for other methods...
```

## Advanced Usage

### Custom Headers

```tsx
const { data } = useFetchData("/protected-resource", {
  axiosOptions: {
    headers: {
      "Custom-Header": "value",
    },
  },
});
```

### Request Cancellation

React Query automatically handles request cancellation when components unmount.

### Error Handling

The API utility includes global error handling, but you can also handle errors at the component level:

```tsx
const { error, isError } = useFetchData("/users");

if (isError) {
  // Handle error specifically for this component
  return <div>Error: {error}</div>;
}
```

## Best Practices

1. **Use Consistent Query Keys**: Organize your query keys logically to ensure proper cache invalidation.
2. **Invalidate Queries Properly**: When mutating data, invalidate the relevant queries to keep data fresh.
3. **Set Appropriate Stale Times**: Configure staleTime based on how frequently your data changes.
4. **Use Optimistic Updates**: For better UX, update the UI optimistically before the server confirms changes.
5. **Handle Loading and Error States**: Always provide feedback to users during loading and error states.

## Troubleshooting

- **Caching Issues**: If data isn't refreshing as expected, check your query keys and invalidation logic.
- **Type Errors**: Ensure you're using proper TypeScript types for your API responses.
- **Authentication Errors**: Verify that your auth tokens are being properly included in requests.

## Contributing

Feel free to enhance this utility with additional features or improvements!
